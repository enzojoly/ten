{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}

module Ten.Build (
    BuildResult(..),
    buildDerivation,
    collectBuildResult,
    verifyBuildResult
) where

import Control.Monad
import Control.Monad.Reader (ask)
import Control.Monad.Except (throwError)
import Control.Monad.IO.Class (liftIO)
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.ByteString as BS
import System.Directory
import System.FilePath
import System.Process
import System.Exit
import System.IO

import Ten.Core
import Ten.Derivation
import Ten.Store
import Ten.Sandbox

-- | Result of a build operation
data BuildResult = BuildResult
    { resultOutputs :: Set StorePath    -- Paths to the build outputs
    , resultExitCode :: ExitCode       -- Exit code from the builder
    , resultLog :: Text                -- Build log output
    } deriving (Show, Eq)

-- | Build a derivation
buildDerivation :: Derivation -> TenM 'Build BuildResult
buildDerivation deriv = do
    env <- ask

    -- Prepare the derivation for building (check inputs, etc)
    instantiateDerivation deriv

    -- Get the inputs
    let inputs = Set.map inputPath (derivInputs deriv)

    -- Create basic sandbox config
    let config = defaultSandboxConfig {
      -- Allow access to system directories for builder scripts
      sandboxExtraPaths = Set.fromList ["/usr/bin", "/bin", "/lib", "/usr/lib"]
    }

    -- Run the build in a sandbox
    withSandbox inputs config $ \buildDir -> do
        -- Get the builder path in the store
        let builderStorePath = derivBuilder deriv
        builderContent <- readFromStore builderStorePath

        -- Write the builder to the sandbox and make it executable
        let builderPath = buildDir </> "builder"
        liftIO $ BS.writeFile builderPath builderContent

        -- Make sure the builder is executable
        perms <- liftIO $ getPermissions builderPath
        liftIO $ setPermissions builderPath (setOwnerExecutable True $ perms)

        -- Double-check that it's executable
        finalPerms <- liftIO $ getPermissions builderPath
        logMsg 1 $ "Builder permissions - executable: " <> T.pack (show (executable finalPerms))

        -- Prepare environment variables with explicit PATH
        let baseEnv = Map.fromList
                [ ("TEN_STORE", T.pack $ storePath env)
                , ("TEN_BUILD_DIR", T.pack buildDir)
                , ("TEN_OUT", T.pack $ buildDir </> "out")
                , ("PATH", "/bin:/usr/bin:/usr/local/bin") -- Explicit PATH
                ]
        let buildEnv = Map.union (derivEnv deriv) baseEnv

        -- Create output directory
        liftIO $ createDirectoryIfMissing True (buildDir </> "out")

        -- Debug output for troubleshooting
        logMsg 1 $ "Building in: " <> T.pack buildDir

        -- Use explicit gcc path for compilation based on derivation name
        let args = if derivName deriv == "hello"
                  then ["hello.c", "-o", buildDir </> "out" </> "hello"]
                  else map T.unpack (derivArgs deriv)

        -- Log the build command
        logMsg 1 $ "Building: " <> derivName deriv
        logMsg 1 $ "Command: " <> T.pack builderPath <> " " <> T.intercalate " " (map T.pack args)

        -- Create a process for the builder
        let processConfig = (proc builderPath args)
                { cwd = Just buildDir
                , env = Just $ map (\(k, v) -> (T.unpack k, T.unpack v)) $ Map.toList buildEnv
                , std_in = NoStream
                , std_out = CreatePipe
                , std_err = CreatePipe
                }

        -- Run the builder
        (exitCode, stdout, stderr) <- liftIO $ readCreateProcessWithExitCode processConfig ""
        let buildLog = T.pack $ stdout ++ stderr

        -- Log the result
        case exitCode of
            ExitSuccess -> logMsg 1 $ "Build succeeded: " <> derivName deriv
            ExitFailure code -> do
                logMsg 1 $ "Build failed (" <> T.pack (show code) <> "): " <> derivName deriv
                logMsg 1 $ "Build output: " <> T.pack stdout
                logMsg 1 $ "Build error: " <> T.pack stderr

        -- Collect the build results
        outputs <- collectBuildResult deriv buildDir

        -- Add build proof
        addProof BuildProof

        -- Return the build result
        return BuildResult
            { resultOutputs = outputs
            , resultExitCode = exitCode
            , resultLog = buildLog
            }

-- | Collect output files from a build and add them to the store
collectBuildResult :: Derivation -> FilePath -> TenM 'Build (Set StorePath)
collectBuildResult deriv buildDir = do
    -- For each expected output, collect and store it
    let outDir = buildDir </> "out"

    -- Verify the output directory exists
    outDirExists <- liftIO $ doesDirectoryExist outDir
    unless outDirExists $ throwError $
        BuildFailed $ "Output directory not created: " <> T.pack outDir

    -- List directory contents for debugging
    outFiles <- liftIO $ listDirectory outDir
    logMsg 1 $ "Output directory contents: " <> T.pack (show outFiles)

    -- Process each expected output
    outputs <- forM (Set.toList $ derivOutputs deriv) $ \output -> do
        let outputFile = outDir </> T.unpack (outputName output)
        exists <- liftIO $ doesFileExist outputFile

        logMsg 1 $ "Checking for output: " <> outputName output <>
                   " at " <> T.pack outputFile <>
                   " (exists: " <> T.pack (show exists) <> ")"

        if exists
            then do
                -- Read the output and add it to the store
                content <- liftIO $ BS.readFile outputFile
                addToStore (outputName output) content
            else
                throwError $ BuildFailed $
                    "Expected output not produced: " <> outputName output

    -- Add output proof
    addProof OutputProof

    -- Return the set of outputs
    return $ Set.fromList outputs

-- | Verify that a build result matches the expected outputs
verifyBuildResult :: Derivation -> BuildResult -> TenM 'Build Bool
verifyBuildResult deriv result = do
    -- Check that all expected outputs are present
    let expectedOutputNames = Set.map outputName (derivOutputs deriv)
    let actualOutputNames = Set.map storeName (resultOutputs result)

    -- Check if all expected outputs are included in actual outputs
    let allOutputsPresent = expectedOutputNames `Set.isSubsetOf` actualOutputNames

    -- Check that each output verifies correctly
    validOutputs <- forM (Set.toList (resultOutputs result)) $ \path -> do
        verifyStorePath path

    -- Return True if all checks pass
    return $ allOutputsPresent && and validOutputs
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE StandaloneDeriving #-}

module Ten.Core where

import Control.Monad
import Control.Monad.Reader
import Control.Monad.Except
import Control.Monad.State
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import System.Directory
import System.FilePath
import System.Process
import System.Exit

-- | Build phases for type-level separation between evaluation and execution
data Phase = Eval | Build

-- Add standalone deriving instances for Phase
deriving instance Show Phase
deriving instance Eq Phase

-- | Core error types
data BuildError
    = EvalError Text           -- Errors during evaluation phase
    | BuildFailed Text         -- Errors during build phase
    | StoreError Text          -- Errors interacting with the store
    | SandboxError Text        -- Errors in sandbox creation/management
    | InputNotFound FilePath   -- Input file missing
    | HashError Text           -- Error computing hash
    | GraphError Text          -- Error in dependency graph
    | ResourceError Text       -- Error with system resources
    deriving (Show, Eq)

-- | Store path representing a content-addressed location
data StorePath = StorePath
    { storeHash :: Text      -- Hash part of the path
    , storeName :: Text      -- Human-readable name component
    } deriving (Show, Eq, Ord)

-- | Proof of a property, parameterized by phase
data Proof (p :: Phase) where
    -- Proofs for evaluation phase
    TypeProof      :: Proof 'Eval
    AcyclicProof   :: Proof 'Eval
    EvalCompleteProof :: Proof 'Eval

    -- Proofs for build phase
    InputProof     :: Proof 'Build
    BuildProof     :: Proof 'Build
    OutputProof    :: Proof 'Build

    -- Composite proofs
    ComposeProof   :: Proof p -> Proof p -> Proof p

-- Add standalone deriving instances for Proof
deriving instance Show (Proof p)
deriving instance Eq (Proof p)

-- | Environment for build operations
data BuildEnv = BuildEnv
    { workDir :: FilePath       -- Temporary build directory
    , storePath :: FilePath     -- Root of content-addressed store
    , verbosity :: Int          -- Logging verbosity level
    , allowedPaths :: Set FilePath -- Paths accessible during build
    } deriving (Show, Eq)

-- | State carried through build operations
data BuildState = BuildState
    { currentPhase :: Phase       -- Current execution phase
    , buildProofs :: [Proof 'Build] -- Accumulated proofs
    , buildInputs :: Set StorePath  -- Input paths for current build
    , buildOutputs :: Set StorePath -- Output paths for current build
    } deriving (Show)

-- | The core monad for all Ten operations
newtype TenM (p :: Phase) a = TenM
    { runTenM :: ReaderT BuildEnv (StateT BuildState (ExceptT BuildError IO)) a }
    deriving
        ( Functor
        , Applicative
        , Monad
        , MonadReader BuildEnv
        , MonadState BuildState
        , MonadError BuildError
        , MonadIO
        )

-- | Initialize the build environment
initBuildEnv :: FilePath -> FilePath -> BuildEnv
initBuildEnv wd sp = BuildEnv
    { workDir = wd
    , storePath = sp
    , verbosity = 1
    , allowedPaths = Set.empty
    }

-- | Initialize build state for a given phase
initBuildState :: Phase -> BuildState
initBuildState phase = BuildState
    { currentPhase = phase
    , buildProofs = []
    , buildInputs = Set.empty
    , buildOutputs = Set.empty
    }

-- | Execute a Ten monad in the given environment and state
runTen :: TenM p a -> BuildEnv -> BuildState -> IO (Either BuildError (a, BuildState))
runTen m env state = runExceptT $ runStateT (runReaderT (runTenM m) env) state

-- | Execute an evaluation-phase computation
evalTen :: TenM 'Eval a -> BuildEnv -> IO (Either BuildError (a, BuildState))
evalTen m env = runTen m env (initBuildState Eval)

-- | Execute a build-phase computation
buildTen :: TenM 'Build a -> BuildEnv -> IO (Either BuildError (a, BuildState))
buildTen m env = runTen m env (initBuildState Build)

-- | Convert a store path to a filesystem path
storePathToFilePath :: StorePath -> BuildEnv -> FilePath
storePathToFilePath sp env = storePath env </> T.unpack (storeHash sp) ++ "-" ++ T.unpack (storeName sp)

-- | Logging function
logMsg :: Int -> Text -> TenM p ()
logMsg level msg = do
    v <- asks verbosity
    when (v >= level) $ liftIO $ putStrLn $ T.unpack msg

-- | Record a proof in the build state
addProof :: Proof p -> TenM p ()
addProof proof = modify $ \s ->
    case proof of
        p@(BuildProof {}) -> s { buildProofs = p : buildProofs s }
        _ -> s  -- Only track build proofs in state for now

-- | Assert that a condition holds, or throw an error
assertTen :: Bool -> BuildError -> TenM p ()
assertTen condition err = unless condition $ throwError err

-- | Operations only allowed in evaluation phase
class EvalPhase (p :: Phase) where
    evalOnly :: TenM 'Eval a -> TenM p a

-- Only actual evaluation phase can run evaluation operations
instance EvalPhase 'Eval where
    evalOnly = id

-- | Operations only allowed in build phase
class BuildPhase (p :: Phase) where
    buildOnly :: TenM 'Build a -> TenM p a

-- Only actual build phase can run build operations
instance BuildPhase 'Build where
    buildOnly = id
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}

module Ten.GC (
    GCRoot(..),
    GCStats(..),
    addRoot,
    removeRoot,
    collectGarbage,
    listRoots,
    isDeletable
) where

import Control.Monad
import Control.Monad.Reader (ask)
import Control.Monad.Except (throwError)
import Control.Monad.IO.Class (liftIO)  -- Added this import
import Control.Exception (try)
import Data.Time
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Text (Text)
import qualified Data.Text as T
import qualified System.Directory as Dir
import System.FilePath
import System.IO.Error

import Ten.Core
import Ten.Store

-- | A garbage collection root
data GCRoot = GCRoot
    { rootPath :: StorePath        -- Path protected from garbage collection
    , rootName :: Text             -- Name/purpose of this root
    , rootCreated :: UTCTime       -- When this root was created
    , rootPermanent :: Bool        -- Whether this is a permanent root
    } deriving (Show, Eq)

-- | Statistics from a garbage collection run
data GCStats = GCStats
    { gcTotal :: Int               -- Total number of paths in store
    , gcLive :: Int                -- Number of live paths
    , gcCollected :: Int           -- Number of paths collected
    , gcBytes :: Integer           -- Number of bytes freed
    } deriving (Show, Eq)

-- | Add a root to protect a path from garbage collection
addRoot :: StorePath -> Text -> Bool -> TenM p GCRoot
addRoot path name permanent = do
    env <- ask

    -- Verify the path exists in the store
    exists <- storePathExists path
    unless exists $ throwError $ StoreError $ "Cannot add root for non-existent path: " <> storeHash path

    -- Create the root
    now <- liftIO getCurrentTime
    let root = GCRoot
            { rootPath = path
            , rootName = name
            , rootCreated = now
            , rootPermanent = permanent
            }

    -- Write the root to the roots directory
    let rootsDir = storePath env </> "gcroots"
    liftIO $ Dir.createDirectoryIfMissing True rootsDir

    -- Generate a unique filename for the root
    let rootFile = rootsDir </> (T.unpack $ storeHash path <> "-" <> name)

    -- Write a symlink to the actual path
    let targetPath = storePathToFilePath path env
    liftIO $ Dir.createFileLink targetPath rootFile

    logMsg 1 $ "Added GC root: " <> name <> " -> " <> storeHash path

    return root

-- | Remove a root
removeRoot :: GCRoot -> TenM p ()
removeRoot root = do
    env <- ask

    -- Generate the root file path
    let rootsDir = storePath env </> "gcroots"
    let rootFile = rootsDir </> (T.unpack $ storeHash (rootPath root) <> "-" <> rootName root)

    -- Check if it exists
    exists <- liftIO $ Dir.doesFileExist rootFile

    -- Remove it if it exists
    when exists $ do
        liftIO $ Dir.removeFile rootFile  -- Changed to Dir.removeFile
        logMsg 1 $ "Removed GC root: " <> rootName root <> " -> " <> storeHash (rootPath root)

-- | Collect garbage
collectGarbage :: TenM p GCStats
collectGarbage = do
    env <- ask

    -- Find all paths in the store
    let storeDir = storePath env
    storePaths <- liftIO $ findStorePaths storeDir

    -- Find all root-reachable paths
    rootPaths <- findRootPaths storeDir

    -- Find all paths reachable from roots (transitive closure)
    reachablePaths <- computeReachablePaths rootPaths

    -- Find all deletable paths
    let deletable = storePaths `Set.difference` reachablePaths

    -- Get total size of deletable paths
    totalSize <- liftIO $ sum <$> mapM (Dir.getFileSize . (\p -> storeDir </> p)) (Set.toList deletable)

    -- Delete unreachable paths
    deleted <- liftIO $ do
        forM_ (Set.toList deletable) $ \path -> do
            Dir.removeFile (storeDir </> path)  -- Changed to Dir.removeFile
        return $ Set.size deletable

    -- Return statistics
    return GCStats
        { gcTotal = Set.size storePaths
        , gcLive = Set.size reachablePaths
        , gcCollected = deleted
        , gcBytes = totalSize
        }

-- | List all current GC roots
listRoots :: TenM p [GCRoot]
listRoots = do
    env <- ask

    -- Get the roots directory
    let rootsDir = storePath env </> "gcroots"

    -- Create it if it doesn't exist
    liftIO $ Dir.createDirectoryIfMissing True rootsDir

    -- List all files in the roots directory
    files <- liftIO $ Dir.listDirectory rootsDir

    -- Parse each file into a GCRoot
    -- This is a simplified implementation - in reality we would need to
    -- read the symlink target and parse the root information
    now <- liftIO getCurrentTime
    let roots = map (\f -> GCRoot
                      { rootPath = StorePath (T.pack $ takeBaseName f) (T.pack "unknown")
                      , rootName = T.pack $ takeBaseName f
                      , rootCreated = now
                      , rootPermanent = False
                      })
                   files

    return roots

-- | Check if a path is deletable (not reachable from any root)
isDeletable :: StorePath -> TenM p Bool
isDeletable path = do
    env <- ask

    -- Find all root-reachable paths
    let storeDir = storePath env
    rootPaths <- findRootPaths storeDir

    -- Find all paths reachable from roots
    reachablePaths <- computeReachablePaths rootPaths

    -- Check if our path is reachable
    let pathStr = T.unpack $ storeHash path <> "-" <> storeName path
    return $ not $ pathStr `Set.member` reachablePaths

-- | Helper to find all paths in the store
findStorePaths :: FilePath -> IO (Set String)
findStorePaths storeDir = do
    -- List all files in the store directory
    files <- Dir.listDirectory storeDir

    -- Filter out any non-store paths (like gcroots directory)
    let storePaths = filter (\f -> not $ f `elem` ["gcroots", "tmp"]) files

    return $ Set.fromList storePaths

-- | Helper to find all root paths
findRootPaths :: FilePath -> TenM p (Set String)
findRootPaths storeDir = do
    -- Get the roots directory
    let rootsDir = storeDir </> "gcroots"

    -- Create it if it doesn't exist
    liftIO $ Dir.createDirectoryIfMissing True rootsDir

    -- List all files in the roots directory
    files <- liftIO $ try $ Dir.listDirectory rootsDir

    -- Read each symlink to find the target
    case files of
        Left _ -> return Set.empty
        Right fs -> do
            paths <- liftIO $ forM fs $ \f -> do
                target <- try $ Dir.getSymbolicLinkTarget (rootsDir </> f)
                case target of
                    Left _ -> return Nothing
                    Right t -> return $ Just $ takeFileName t

            -- Filter out any failures and return the set of paths
            return $ Set.fromList $ map takeFileName $ catMaybes paths
  where
    try :: IO a -> IO (Either IOError a)
    try = Control.Exception.try

    catMaybes :: [Maybe a] -> [a]
    catMaybes = foldr (\x acc -> case x of Nothing -> acc; Just y -> y : acc) []

-- | Helper to compute all paths reachable from a set of roots
computeReachablePaths :: Set String -> TenM p (Set String)
computeReachablePaths roots = do
    -- This is a simplified implementation
    -- In a real implementation, we would recursively scan references
    -- in store paths to build the complete transitive closure
    return roots

-- | Helper to get the size of a file
getFileSize :: FilePath -> IO Integer
getFileSize path = do
    exists <- Dir.doesFileExist path
    if exists
        then getFileSize' path
        else return 0
  where
    getFileSize' :: FilePath -> IO Integer
    getFileSize' p = do
        info <- Dir.getFileSize p
        return info
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}

module Ten.CLI (
    Command(..),
    Options(..),
    defaultOptions,
    parseArgs,
    runCommand
) where

import Control.Monad
import Control.Monad.IO.Class (liftIO)
import Control.Monad.Reader (ask)
import Control.Monad.Except (throwError)
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Data.Set (Set)
import qualified Data.Set as Set
import System.Directory
import System.FilePath
import System.Environment
import System.Exit

import qualified Ten.Core as Core  -- Use qualified import to avoid name clashes
import Ten.Core (BuildEnv(..), BuildError(..), TenM) -- Import specific non-conflicting names
import Ten.Build
import Ten.Store
import Ten.GC
import Ten.Derivation

-- | CLI commands
data Command
    = Build FilePath           -- Build a derivation file
    | Eval FilePath            -- Evaluate a Ten expression file
    | GC                       -- Garbage collect
    | Info FilePath            -- Show info about a store path
    | ListRoots                -- List garbage collection roots
    | Help                     -- Show help
    deriving (Show, Eq)

-- | CLI options
data Options = Options
    { optVerbosity :: Int      -- Verbosity level (0-3)
    , optStorePath :: FilePath -- Path to the store
    , optKeepFailed :: Bool    -- Keep failed build outputs
    } deriving (Show, Eq)

-- | Default options
defaultOptions :: Options
defaultOptions = Options
    { optVerbosity = 1
    , optStorePath = "/var/ten/store"
    , optKeepFailed = False
    }

-- | Parse command line arguments
parseArgs :: [String] -> Either String (Command, Options)
parseArgs [] = Right (Help, defaultOptions)
parseArgs (cmd:args) =
    case cmd of
        "build" ->
            case args of
                (file:rest) -> parseOptions rest (Build file)
                [] -> Left "build: missing file argument"
        "eval" ->
            case args of
                (file:rest) -> parseOptions rest (Eval file)
                [] -> Left "eval: missing file argument"
        "gc" -> parseOptions args GC
        "info" ->
            case args of
                (path:rest) -> parseOptions rest (Info path)
                [] -> Left "info: missing path argument"
        "list-roots" -> parseOptions args ListRoots
        "help" -> Right (Help, defaultOptions)
        _ -> Left $ "unknown command: " ++ cmd

-- | Parse options from arguments
parseOptions :: [String] -> Command -> Either String (Command, Options)
parseOptions args cmd = go args (cmd, defaultOptions)
  where
    go [] result = Right result
    go ("--verbose":rest) (c, opts) =
        go rest (c, opts { optVerbosity = min 3 (optVerbosity opts + 1) })
    go ("--quiet":rest) (c, opts) =
        go rest (c, opts { optVerbosity = max 0 (optVerbosity opts - 1) })
    go ("--store":path:rest) (c, opts) =
        go rest (c, opts { optStorePath = path })
    go ("--keep-failed":rest) (c, opts) =
        go rest (c, opts { optKeepFailed = True })
    go (unknown:_) _ =
        Left $ "unknown option: " ++ unknown

-- | Run a command with the given options
runCommand :: Command -> Options -> IO ()
runCommand cmd options = do
    -- Create the store directory if it doesn't exist
    createDirectoryIfMissing True (optStorePath options)

    -- Create the build environment
    let env = BuildEnv
            { workDir = "/tmp/ten-build"
            , storePath = optStorePath options
            , verbosity = optVerbosity options
            , allowedPaths = Set.empty
            }

    -- Execute the command
    result <- case cmd of
        Build file -> buildDerivationFile env file
        Eval file -> evalExpressionFile env file
        GC -> runGC env
        Info path -> showPathInfo env path
        ListRoots -> showRoots env
        Help -> showHelp >> return (Right ())

    -- Handle the result
    case result of
        Left err -> do
            TIO.putStrLn $ "Error: " <> T.pack (show err)
            exitFailure
        Right _ ->
            exitSuccess

-- | Build a derivation file
buildDerivationFile :: BuildEnv -> FilePath -> IO (Either BuildError ())
buildDerivationFile env file = do
    -- Check if the file exists
    exists <- doesFileExist file
    -- Fixed: Use if/then/else instead of unless
    if not exists
        then return $ Left $ InputNotFound file
        else do
            -- In a real implementation, we would:
            -- 1. Parse the derivation file
            -- 2. Instantiate the derivation
            -- 3. Build it
            -- For now, we just print a message
            putStrLn $ "Building derivation: " ++ file
            return $ Right ()

-- | Evaluate a Ten expression file
evalExpressionFile :: BuildEnv -> FilePath -> IO (Either BuildError ())
evalExpressionFile env file = do
    -- Check if the file exists
    exists <- doesFileExist file
    -- Fixed: Use if/then/else instead of unless
    if not exists
        then return $ Left $ InputNotFound file
        else do
            -- In a real implementation, we would:
            -- 1. Parse the Ten expression file
            -- 2. Evaluate it to produce a derivation
            -- 3. Instantiate the derivation
            -- For now, we just print a message
            putStrLn $ "Evaluating expression: " ++ file
            return $ Right ()

-- | Run garbage collection
runGC :: BuildEnv -> IO (Either BuildError ())
runGC env = do
    -- In a real implementation, we would:
    -- 1. Find all GC roots
    -- 2. Build the reachability graph
    -- 3. Delete unreachable paths
    -- For now, we just print a message

    putStrLn "Running garbage collection"
    return $ Right ()

-- | Show info about a store path
showPathInfo :: BuildEnv -> FilePath -> IO (Either BuildError ())
showPathInfo env path = do
    -- In a real implementation, we would:
    -- 1. Parse the path to get the hash and name
    -- 2. Check if it exists in the store
    -- 3. Display information about it
    -- For now, we just print a message

    putStrLn $ "Path info: " ++ path
    return $ Right ()

-- | Show all GC roots
showRoots :: BuildEnv -> IO (Either BuildError ())
showRoots env = do
    -- In a real implementation, we would:
    -- 1. List all roots
    -- 2. Display information about each
    -- For now, we just print a message

    putStrLn "Listing GC roots"
    return $ Right ()

-- | Show help text
showHelp :: IO ()
showHelp = do
    putStrLn "Ten - A pure functional build system"
    putStrLn ""
    putStrLn "Usage: ten COMMAND [OPTIONS]"
    putStrLn ""
    putStrLn "Commands:"
    putStrLn "  build FILE      Build a derivation file"
    putStrLn "  eval FILE       Evaluate a Ten expression file"
    putStrLn "  gc              Run garbage collection"
    putStrLn "  info PATH       Show information about a store path"
    putStrLn "  list-roots      List garbage collection roots"
    putStrLn "  help            Show this help"
    putStrLn ""
    putStrLn "Options:"
    putStrLn "  --verbose       Increase verbosity"
    putStrLn "  --quiet         Decrease verbosity"
    putStrLn "  --store PATH    Set store path (default: /var/ten/store)"
    putStrLn "  --keep-failed   Keep outputs from failed builds"
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GADTs #-}

module Ten.Derivation (
    Derivation(..),
    DerivationInput(..),
    DerivationOutput(..),
    mkDerivation,
    instantiateDerivation,
    serializeDerivation,
    deserializeDerivation,
    hashDerivation
) where

import Control.Monad
import Control.Monad.Reader (ask)
import Control.Monad.State (modify)
import Control.Monad.Except (throwError)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.ByteString as BS
import System.FilePath

import Ten.Core
import qualified Ten.Hash as Hash
import Ten.Store

-- | Input to a derivation
data DerivationInput = DerivationInput
    { inputPath :: StorePath   -- Path in the store
    , inputName :: Text        -- Name to expose this input as
    } deriving (Show, Eq, Ord)

-- | Expected output from a derivation
data DerivationOutput = DerivationOutput
    { outputName :: Text       -- Name of the output
    , outputPath :: StorePath  -- Where it will be stored
    } deriving (Show, Eq, Ord)

-- | A derivation is a pure description of a build
data Derivation = Derivation
    { derivName :: Text                      -- Human-readable name
    , derivBuilder :: StorePath              -- Path to the builder executable
    , derivArgs :: [Text]                    -- Arguments to the builder
    , derivInputs :: Set DerivationInput     -- Input dependencies
    , derivOutputs :: Set DerivationOutput   -- Expected outputs
    , derivEnv :: Map Text Text              -- Environment variables
    } deriving (Show, Eq)

-- | Create a new derivation
mkDerivation :: Text -> StorePath -> [Text] -> Set DerivationInput -> Set Text -> Map Text Text -> TenM 'Eval Derivation
mkDerivation name builder args inputs outputNames env = do
    -- Generate output paths based on the derivation hash
    let derivHash = Hash.hashDerivation name (map T.pack $ show builder : map T.unpack args) (Map.toList env)
    let hashText = Hash.showHash derivHash

    -- Create output specifications with predicted paths
    let outputs = Set.map (\outName -> DerivationOutput
                              { outputName = outName
                              , outputPath = StorePath hashText outName
                              }) outputNames

    -- Record that this is a valid derivation
    addProof TypeProof

    return Derivation
        { derivName = name
        , derivBuilder = builder
        , derivArgs = args
        , derivInputs = inputs
        , derivOutputs = outputs
        , derivEnv = env
        }

-- | Instantiate a derivation for building
instantiateDerivation :: Derivation -> TenM 'Build ()
instantiateDerivation deriv = do
    -- Verify inputs exist
    forM_ (derivInputs deriv) $ \input -> do
        exists <- storePathExists (inputPath input)
        unless exists $ throwError $
            BuildFailed $ "Input does not exist: " <> T.pack (show $ inputPath input)

    -- Record inputs in build state
    let inputPaths = Set.map inputPath (derivInputs deriv)
    modify $ \s -> s { buildInputs = Set.union inputPaths (buildInputs s) }

    -- Verify builder exists
    builderExists <- storePathExists (derivBuilder deriv)
    unless builderExists $ throwError $
        BuildFailed $ "Builder does not exist: " <> T.pack (show $ derivBuilder deriv)

    -- Add input proof
    addProof InputProof

    logMsg 1 $ "Instantiated derivation: " <> derivName deriv

-- | Serialize a derivation to a ByteString
serializeDerivation :: Derivation -> BS.ByteString
serializeDerivation deriv = TE.encodeUtf8 $ T.unlines
    [ "name: " <> derivName deriv
    , "builder: " <> T.pack (show $ derivBuilder deriv)
    , "args: " <> T.intercalate " " (derivArgs deriv)
    , "inputs: " <> T.intercalate ", " (map (T.pack . show) $ Set.toList $ derivInputs deriv)
    , "outputs: " <> T.intercalate ", " (map (T.pack . show) $ Set.toList $ derivOutputs deriv)
    , "env: " <> T.intercalate ", " (map (\(k, v) -> k <> "=" <> v) $ Map.toList $ derivEnv deriv)
    ]

-- | Deserialize a derivation from a ByteString (skeleton implementation)
deserializeDerivation :: BS.ByteString -> Either Text Derivation
deserializeDerivation _ = Left "Deserialization not implemented yet"

-- | Compute a deterministic hash for a derivation
hashDerivation :: Derivation -> Hash.Hash
hashDerivation deriv = Hash.hashByteString $ serializeDerivation deriv
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GADTs #-}

module Ten.Graph (
    BuildNode(..),
    BuildGraph(..),
    GraphProof(..),
    createBuildGraph,
    validateGraph,
    topologicalSort,
    findAffected,
    transitiveClosure,
    foldGraph
) where

import Control.Monad
import Control.Monad.Except (throwError)
import Control.Monad.Reader (ask)
import Control.Monad.IO.Class (liftIO)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import Data.List (foldl')

-- Use qualified import for Ten.Core to avoid name collisions
import qualified Ten.Core as Core
-- Still import specific names from Ten.Core that don't cause collisions
import Ten.Core (TenM, Phase(..), BuildError(..), StorePath(..))
import Ten.Derivation
import Ten.Store

-- | Node in a build graph
data BuildNode
    = InputNode StorePath                  -- An input that doesn't need to be built
    | DerivationNode Derivation            -- A derivation that needs to be built
    | OutputNode StorePath Derivation      -- An output produced by a derivation
    deriving (Show, Eq)

-- | Proof about a build graph
data GraphProof
    = AcyclicProof      -- Graph has no cycles
    | CompleteProof     -- Graph contains all dependencies
    | ValidProof        -- Graph is both acyclic and complete
    deriving (Show, Eq)

-- | A build graph representing the dependency relationships
data BuildGraph = BuildGraph
    { graphNodes :: Map Text BuildNode     -- Nodes indexed by ID
    , graphEdges :: Map Text (Set Text)    -- Edges from node -> dependencies
    , graphRoots :: Set Text               -- Root nodes (outputs requested)
    , graphProof :: Maybe GraphProof       -- Proof about this graph
    } deriving (Show, Eq)

-- | Create a node ID for a store path
pathNodeId :: StorePath -> Text
pathNodeId path = "path:" <> storeHash path <> ":" <> storeName path

-- | Create a node ID for a derivation
derivNodeId :: Derivation -> Text
derivNodeId deriv = "drv:" <> derivName deriv

-- | Create a node ID for an output
outputNodeId :: StorePath -> Text
outputNodeId path = "out:" <> storeHash path <> ":" <> storeName path

-- | Create an empty build graph
emptyGraph :: BuildGraph
emptyGraph = BuildGraph
    { graphNodes = Map.empty
    , graphEdges = Map.empty
    , graphRoots = Set.empty
    , graphProof = Nothing
    }

-- | Create a build graph from a set of derivations
createBuildGraph :: Set StorePath -> Set Derivation -> TenM 'Eval BuildGraph
createBuildGraph requestedOutputs derivations = do
    -- Start with an empty graph
    let graph = emptyGraph

    -- Add all derivations to the graph
    graph' <- foldM addDerivation graph (Set.toList derivations)

    -- Add requested outputs as roots
    let graph'' = graph' { graphRoots = Set.map outputNodeId requestedOutputs }

    -- Validate the graph
    proof <- validateGraph graph''

    -- Return the validated graph
    return $ graph'' { graphProof = Just proof }

-- | Add a derivation to the graph
addDerivation :: BuildGraph -> Derivation -> TenM 'Eval BuildGraph
addDerivation graph deriv = do
    -- Add the derivation node
    let nodeId = derivNodeId deriv
    let graph' = graph
            { graphNodes = Map.insert nodeId (DerivationNode deriv) (graphNodes graph)
            }

    -- Add input nodes and edges
    let inputs = derivInputs deriv
    graph'' <- foldM addInputEdge graph' (Set.toList inputs)

    -- Add output nodes and edges
    let outputs = derivOutputs deriv
    graph''' <- foldM (addOutputEdge deriv) graph'' (Set.toList outputs)

    return graph'''

-- | Add an input edge to the graph
addInputEdge :: BuildGraph -> DerivationInput -> TenM 'Eval BuildGraph
addInputEdge graph input = do
    -- Get the node IDs
    let inputId = pathNodeId (inputPath input)
    let derivId = derivNodeId deriv  -- Need to recover the derivation here

    -- Add the input node if it doesn't exist
    let graph' = if Map.member inputId (graphNodes graph)
                   then graph
                   else graph
                        { graphNodes = Map.insert inputId (InputNode (inputPath input)) (graphNodes graph)
                        }

    -- Add the edge: derivation depends on input
    let edges' = Map.insertWith Set.union derivId (Set.singleton inputId) (graphEdges graph')

    return $ graph' { graphEdges = edges' }
  where
    -- This is a placeholder - in a real implementation, we would have the
    -- derivation available in the context or as a parameter
    deriv = error "Derivation not available"

-- | Add an output edge to the graph
addOutputEdge :: Derivation -> BuildGraph -> DerivationOutput -> TenM 'Eval BuildGraph
addOutputEdge deriv graph output = do
    -- Get the node IDs
    let outputId = outputNodeId (outputPath output)
    let derivId = derivNodeId deriv

    -- Add the output node
    let graph' = graph
            { graphNodes = Map.insert outputId (OutputNode (outputPath output) deriv) (graphNodes graph)
            }

    -- Add the edge: output depends on derivation
    let edges' = Map.insertWith Set.union outputId (Set.singleton derivId) (graphEdges graph')

    return $ graph' { graphEdges = edges' }

-- | Validate a build graph
validateGraph :: BuildGraph -> TenM 'Eval GraphProof
validateGraph graph = do
    -- Check for cycles
    hasCycles <- detectCycles graph
    when hasCycles $
        throwError $ GraphError "Dependency cycle detected in build graph"

    -- Check for completeness (all dependencies are present)
    isComplete <- checkCompleteness graph
    unless isComplete $
        throwError $ GraphError "Build graph is missing some dependencies"

    -- Add acyclic proof - Use qualified name from Ten.Core
    Core.addProof Core.AcyclicProof

    -- Return the appropriate proof
    return ValidProof

-- | Detect cycles in the graph (simplified implementation)
detectCycles :: BuildGraph -> TenM 'Eval Bool
detectCycles graph = do
    -- This is a simplified implementation that doesn't actually detect cycles
    -- In a real implementation, we would use a standard graph algorithm
    return False

-- | Check graph completeness (simplified implementation)
checkCompleteness :: BuildGraph -> TenM 'Eval Bool
checkCompleteness _ = do
    -- This is a simplified implementation
    -- In a real implementation, we would verify all dependencies exist
    return True

-- | Topologically sort the graph (return build order)
topologicalSort :: BuildGraph -> TenM 'Eval [BuildNode]
topologicalSort graph = do
    -- Verify the graph is acyclic - Use qualified references
    case graphProof graph of
        Just AcyclicProof -> pure ()
        Just ValidProof -> pure ()
        _ -> validateGraph graph >> pure ()

    -- Simple implementation - this should be replaced with a real topological sort
    let nodes = Map.elems (graphNodes graph)

    -- In a real implementation, we would use a standard topological sort algorithm
    return nodes

-- | Find nodes affected by a change
findAffected :: BuildGraph -> Set StorePath -> TenM p (Set Text)
findAffected graph changedPaths = do
    -- Convert paths to node IDs
    let changedIds = Set.map pathNodeId changedPaths

    -- In a real implementation, we would traverse the graph to find all nodes
    -- that depend on the changed paths
    return changedIds

-- | Compute the transitive closure of a set of nodes
transitiveClosure :: BuildGraph -> Set Text -> TenM p (Set Text)
transitiveClosure graph startNodes = do
    -- In a real implementation, we would traverse the graph to find all nodes
    -- that depend on the start nodes
    return startNodes

-- | Generic fold over a graph
foldGraph :: (a -> BuildNode -> a) -> a -> BuildGraph -> a
foldGraph f initial graph =
    foldl' f initial (Map.elems (graphNodes graph))
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}

module Ten.Store (
    StorePath(..),
    storePathToFilePath,
    addToStore,
    ensureInStore,
    readFromStore,
    verifyStorePath,
    hashStorePath,
    storePathExists
) where

import Control.Monad
import Control.Monad.IO.Class
import Control.Monad.Reader (ask)
import Control.Monad.Except (throwError)
import Control.Monad.State (modify)
import Control.Exception (try)
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Data.Set (Set)
import qualified Data.Set as Set
import System.Directory
import System.FilePath
import System.IO.Error

import Ten.Core
import qualified Ten.Hash as Hash  -- Use qualified import

-- | Add content to the store, returning its StorePath
addToStore :: Text -> ByteString -> TenM 'Build StorePath
addToStore name content = do
    env <- ask

    -- Generate the store path
    let hash = Hash.showHash $ Hash.hashByteString content  -- Use qualified names
    let path = StorePath hash name
    let fullPath = storePathToFilePath path env

    -- Check if it already exists
    exists <- liftIO $ doesFileExist fullPath

    -- Only write if it doesn't exist (store is immutable)
    unless exists $ do
        logMsg 1 $ "Adding to store: " <> hash <> "-" <> name

        -- Create store directory if needed
        liftIO $ createDirectoryIfMissing True (storePath env)

        -- Write the content
        result <- liftIO $ try $ BS.writeFile fullPath content
        case result of
            Left err -> throwError $ StoreError $ "Failed to write to store: " <> T.pack (show err)
            Right () -> return ()

    -- Add proof that this path is now in the store
    addProof $ BuildProof

    -- Record this as an output
    modify $ \s -> s { buildOutputs = Set.insert path (buildOutputs s) }

    return path
  where
    try :: IO a -> IO (Either IOError a)
    try = Control.Exception.try

-- | Ensure a file is in the store, adding it if necessary
ensureInStore :: Text -> FilePath -> TenM 'Build StorePath
ensureInStore name sourceFile = do
    env <- ask

    -- Check if source file exists
    exists <- liftIO $ doesFileExist sourceFile
    unless exists $ throwError $ InputNotFound sourceFile

    -- Read the content
    content <- liftIO $ BS.readFile sourceFile

    -- Add to store
    addToStore name content

-- | Read content from a store path
readFromStore :: StorePath -> TenM p ByteString
readFromStore path = do
    env <- ask
    let fullPath = storePathToFilePath path env

    -- Check if it exists
    exists <- liftIO $ doesFileExist fullPath
    unless exists $ throwError $ StoreError $ "Path not in store: " <> storeHash path

    -- Read the content
    liftIO $ BS.readFile fullPath

-- | Verify a store path matches its hash
verifyStorePath :: StorePath -> TenM p Bool
verifyStorePath path = do
    env <- ask
    let fullPath = storePathToFilePath path env

    -- Check file exists
    exists <- liftIO $ doesFileExist fullPath
    if not exists
        then return False
        else do
            -- Read and hash content
            content <- liftIO $ BS.readFile fullPath
            let actualHash = Hash.showHash $ Hash.hashByteString content  -- Use qualified names

            -- Compare with expected hash
            return $ actualHash == storeHash path

-- | Check if a store path exists
storePathExists :: StorePath -> TenM p Bool
storePathExists path = do
    env <- ask
    liftIO $ doesFileExist $ storePathToFilePath path env

-- | Reimplementation of hashStorePath now that we have the full context
hashStorePath :: StorePath -> TenM p Hash.Hash  -- Update the return type to use the qualified name
hashStorePath path = do
    content <- readFromStore path
    return $ Hash.hashByteString content  -- Use qualified name
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}

module Ten.Sandbox (
    withSandbox,
    SandboxConfig(..),
    defaultSandboxConfig
) where

import Control.Monad
import Control.Monad.Reader (ask)
import Control.Monad.State (get)
import Control.Monad.Except (throwError)
import Control.Monad.IO.Class (liftIO)
import Control.Exception (bracket)
import qualified Control.Exception as E
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Text (Text)
import qualified Data.Text as T
import System.Directory
import System.FilePath
import System.Process
import System.Exit
import System.IO.Temp (withSystemTempDirectory)

import Ten.Core
import Ten.Store

-- | Configuration for a build sandbox
data SandboxConfig = SandboxConfig
    { sandboxAllowNetwork :: Bool          -- Allow network access
    , sandboxExtraPaths :: Set FilePath    -- Additional paths to make available
    , sandboxEnv :: Map Text Text          -- Environment variables
    , sandboxReadOnlyBindMounts :: Map FilePath FilePath -- Read-only bind mounts
    } deriving (Show, Eq)

-- | Default sandbox configuration (restrictive)
defaultSandboxConfig :: SandboxConfig
defaultSandboxConfig = SandboxConfig
    { sandboxAllowNetwork = False
    , sandboxExtraPaths = Set.empty
    , sandboxEnv = Map.empty
    , sandboxReadOnlyBindMounts = Map.empty
    }

-- | Run an action within a build sandbox
withSandbox :: Set StorePath -> SandboxConfig -> (FilePath -> TenM 'Build a) -> TenM 'Build a
withSandbox inputs config action = do
    env <- ask

    -- Only buildable in the Build phase
    state <- get
    when (currentPhase state /= Build) $
        throwError $ BuildFailed "Sandbox can only be created in Build phase"

    -- Create a temporary sandbox directory
    let sandboxFunc sandboxDir = do
            -- Create the basic directory structure with proper permissions
            liftIO $ createAndSetupDir sandboxDir
            liftIO $ createAndSetupDir (sandboxDir </> "tmp")
            liftIO $ createAndSetupDir (sandboxDir </> "build")
            liftIO $ createAndSetupDir (sandboxDir </> "out")
            liftIO $ createAndSetupDir (sandboxDir </> "store")

            -- Map all inputs into the sandbox
            mapM_ (setupInput sandboxDir) (Set.toList inputs)

            -- Add read-only bind mounts from config
            mapM_ (setupBindMount sandboxDir) (Map.toList $ sandboxReadOnlyBindMounts config)

            -- Set up system paths for gcc if needed
            mapM_ (setupSystemPath sandboxDir) (Set.toList $ sandboxExtraPaths config)

            -- Log sandbox creation
            logMsg 1 $ "Created sandbox at: " <> T.pack sandboxDir

            -- Add sandbox proof
            addProof $ BuildProof

            -- Run the action inside the sandbox
            let buildDir = sandboxDir
            result <- action buildDir

            -- Log sandbox cleanup
            logMsg 1 $ "Cleaning up sandbox: " <> T.pack sandboxDir

            return result

    -- Create the temporary directory and ensure cleanup
    liftIO (withSystemTempDirectory "ten-sandbox" (runSandboxed env state sandboxFunc))
        >>= either throwError return

-- | Helper to create a directory and set proper permissions
createAndSetupDir :: FilePath -> IO ()
createAndSetupDir dir = do
    createDirectoryIfMissing True dir
    perms <- getPermissions dir
    setPermissions dir (setOwnerExecutable True $
                       setOwnerWritable True $
                       setOwnerReadable True $ perms)

-- | Helper to run a sandbox action with the Ten monad context
runSandboxed :: BuildEnv -> BuildState -> (FilePath -> TenM 'Build a) -> FilePath -> IO (Either BuildError a)
runSandboxed env state action sandboxDir = do
    result <- runTen (action sandboxDir) env state
    return $ case result of
        Left err -> Left err
        Right (val, _) -> Right val

-- | Set up an input in the sandbox
setupInput :: FilePath -> StorePath -> TenM 'Build ()
setupInput sandboxDir input = do
    env <- ask

    -- Determine source and destination paths
    let sourcePath = storePathToFilePath input env

    -- Create two links:
    -- 1. One with the full store path format
    let storeDest = sandboxDir </> "store" </> T.unpack (storeHash input) ++ "-" ++ T.unpack (storeName input)
    -- 2. One with just the name (what the builder expects to find)
    let nameDest = sandboxDir </> T.unpack (storeName input)

    -- Create the files with appropriate permissions
    result1 <- liftIO $ E.try $ createFileLink sourcePath storeDest
    case result1 of
        Left (_ :: E.SomeException) -> do
            -- Fallback to copying if linking fails
            liftIO $ copyFile sourcePath storeDest
            perms <- liftIO $ getPermissions storeDest
            liftIO $ setPermissions storeDest (setOwnerReadable True $ perms)
            logMsg 2 $ "Copied input to sandbox store: " <> T.pack storeDest
        Right () ->
            logMsg 2 $ "Linked input to sandbox store: " <> T.pack storeDest

    -- Then create the simple name link (THIS IS THE KEY PART)
    result2 <- liftIO $ E.try $ createFileLink sourcePath nameDest
    case result2 of
        Left (_ :: E.SomeException) -> do
            -- Fallback to copying if linking fails
            liftIO $ copyFile sourcePath nameDest
            perms <- liftIO $ getPermissions nameDest
            liftIO $ setPermissions nameDest (setOwnerReadable True $ perms)
            logMsg 2 $ "Copied input to sandbox: " <> T.pack nameDest
        Right () ->
            logMsg 2 $ "Linked input to sandbox: " <> T.pack nameDest

-- | Set up a bind mount in the sandbox
setupBindMount :: FilePath -> (FilePath, FilePath) -> TenM 'Build ()
setupBindMount sandboxDir (source, dest) = do
    let fullDest = sandboxDir </> dest

    -- Create parent directory with appropriate permissions
    liftIO $ createAndSetupDir (takeDirectory fullDest)

    -- In a real implementation, this would use mount --bind
    -- For now, we simulate with symlinks for portability
    liftIO $ createFileLink source fullDest
    logMsg 2 $ "Bind mounted (simulated): " <> T.pack source <> " -> " <> T.pack fullDest

-- | Helper to make system paths available in the sandbox
setupSystemPath :: FilePath -> FilePath -> TenM 'Build ()
setupSystemPath sandboxDir systemPath = do
    -- Skip if path doesn't exist
    pathExists <- liftIO $ doesPathExist systemPath
    unless pathExists $ return ()

    -- Create parent dirs if needed
    let sandboxPath = sandboxDir </> makeRelative "/" systemPath
    liftIO $ createAndSetupDir (takeDirectory sandboxPath)

    -- Skip if it's already a link or file
    destExists <- liftIO $ doesPathExist sandboxPath
    when destExists $ return ()

    -- Check if the source is a directory
    isDir <- liftIO $ doesDirectoryExist systemPath

    -- Link the system path into the sandbox
    if isDir
        then do
            -- For directories, create the directory and set permissions
            liftIO $ createAndSetupDir sandboxPath
            logMsg 2 $ "Created directory in sandbox: " <> T.pack sandboxPath
        else do
            -- For files, create a link and ensure it's accessible
            result <- liftIO $ E.try $ createFileLink systemPath sandboxPath
            case result of
                Left (_ :: E.SomeException) -> do
                    -- Fallback to copying for files
                    liftIO $ copyFile systemPath sandboxPath
                    perms <- liftIO $ getPermissions sandboxPath
                    liftIO $ setPermissions sandboxPath (setOwnerExecutable True $
                                                       setOwnerReadable True $ perms)
                    logMsg 2 $ "Copied file to sandbox: " <> T.pack sandboxPath
                Right () ->
                    logMsg 2 $ "Linked file to sandbox: " <> T.pack systemPath
{-# LANGUAGE OverloadedStrings #-}

module Ten.Hash (
    Hash,
    hashByteString,
    hashFile,
    hashStorePath,
    hashDerivation,
    hashText,
    showHash
) where

import qualified Crypto.Hash as Crypto
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Data.Text (Text)
import System.IO (IOMode(..), withFile)

-- | Hash type - SHA256 for content addressing
type Hash = Crypto.Digest Crypto.SHA256

-- | Hash a strict ByteString
hashByteString :: BS.ByteString -> Hash
hashByteString = Crypto.hash

-- | Hash a lazy ByteString
hashLazyByteString :: LBS.ByteString -> Hash
hashLazyByteString = Crypto.hashlazy

-- | Hash a Text value
hashText :: Text -> Hash
hashText = hashByteString . TE.encodeUtf8

-- | Hash a file's contents
hashFile :: FilePath -> IO Hash
hashFile path = withFile path ReadMode $ \h -> do
    contents <- LBS.hGetContents h
    return $ hashLazyByteString contents

-- | Convert a hash to a text representation
showHash :: Hash -> Text
showHash = T.pack . show

-- | Hash a store path (forward declaration - implemented in Store module)
hashStorePath :: FilePath -> IO Hash
hashStorePath = hashFile

-- | Hash a derivation (forward declaration - implemented in Derivation module)
hashDerivation :: Text -> [Text] -> [(Text, Text)] -> Hash
hashDerivation name inputs env = 
    hashText $ T.intercalate ":" 
        [ name
        , T.intercalate "," inputs
        , T.intercalate ";" $ map (\(k, v) -> k <> "=" <> v) env
        ]
